"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Flamechart = void 0;
const utils_1 = require("./utils");
const math_1 = require("./math");
class Flamechart {
    constructor(source) {
        this.source = source;
        // Bottom to top
        this.layers = [];
        this.totalWeight = 0;
        this.minFrameWidth = 1;
        const stack = [];
        const openFrame = (node, value) => {
            const parent = utils_1.lastOf(stack);
            const frame = {
                node,
                parent,
                children: [],
                start: value,
                end: value,
            };
            if (parent) {
                parent.children.push(frame);
            }
            stack.push(frame);
        };
        this.minFrameWidth = Infinity;
        const closeFrame = (node, value) => {
            console.assert(stack.length > 0);
            const stackTop = stack.pop();
            stackTop.end = value;
            if (stackTop.end - stackTop.start === 0)
                return;
            const layerIndex = stack.length;
            while (this.layers.length <= layerIndex)
                this.layers.push([]);
            this.layers[layerIndex].push(stackTop);
            this.minFrameWidth = Math.min(this.minFrameWidth, stackTop.end - stackTop.start);
        };
        this.totalWeight = source.getTotalWeight();
        source.forEachCall(openFrame, closeFrame);
        if (!isFinite(this.minFrameWidth))
            this.minFrameWidth = 1;
    }
    getTotalWeight() {
        return this.totalWeight;
    }
    getLayers() {
        return this.layers;
    }
    getColorBucketForFrame(frame) {
        return this.source.getColorBucketForFrame(frame);
    }
    getMinFrameWidth() {
        return this.minFrameWidth;
    }
    formatValue(v) {
        return this.source.formatValue(v);
    }
    getClampedViewportWidth(viewportWidth) {
        const maxWidth = this.getTotalWeight();
        // In order to avoid floating point error, we cap the maximum zoom. In
        // particular, it's important that at the maximum zoom level, the total
        // trace size + a viewport width is not equal to the trace size due to
        // floating point rounding.
        //
        // For instance, if the profile's total weight is 2^60, and the viewport
        // size is 1, trying to move one viewport width right will result in no
        // change because 2^60 + 1 = 2^60 in floating point arithmetic. JavaScript
        // numbers are 64 bit floats, and therefore have 53 mantissa bits. You can
        // see this for yourself in the console. Try:
        //
        //   > Math.pow(2, 60) + 1 === Math.pow(2, 60)
        //   true
        //   > Math.pow(2, 53) + 1 === Math.pow(2, 53)
        //   true
        //   > Math.pow(2, 52) + 1 === Math.pow(2, 52)
        //   false
        //
        // We use 2^40 as a cap instead, since we want to be able to make small
        // adjustments within a viewport width.
        //
        // For reference, this will still allow you to zoom until 1 nanosecond fills
        // the screen in a profile with a duration of over 18 minutes.
        //
        //   > Math.pow(2, 40) / (60 * Math.pow(10, 9))
        //   18.325193796266667
        //
        const maxZoom = Math.pow(2, 40);
        // In addition to capping zoom to avoid floating point error, we further cap
        // zoom to avoid letting you zoom in so that the smallest element more than
        // fills the screen, since that probably isn't useful. The final zoom cap is
        // determined by the minimum zoom of either 2^40x zoom or the necessary zoom
        // for the smallest frame to fill the screen three times.
        const minWidth = math_1.clamp(3 * this.getMinFrameWidth(), maxWidth / maxZoom, maxWidth);
        return math_1.clamp(viewportWidth, minWidth, maxWidth);
    }
    // Given a desired config-space viewport rectangle, clamp the rectangle so
    // that it fits within the given flamechart. This prevents the viewport from
    // extending past the bounds of the flamechart or zooming in too far.
    getClampedConfigSpaceViewportRect({ configSpaceViewportRect, renderInverted, }) {
        const configSpaceSize = new math_1.Vec2(this.getTotalWeight(), this.getLayers().length);
        const width = this.getClampedViewportWidth(configSpaceViewportRect.size.x);
        const size = configSpaceViewportRect.size.withX(width);
        const origin = math_1.Vec2.clamp(configSpaceViewportRect.origin, new math_1.Vec2(0, renderInverted ? 0 : -1), math_1.Vec2.max(math_1.Vec2.zero, configSpaceSize.minus(size).plus(new math_1.Vec2(0, 1))));
        return new math_1.Rect(origin, configSpaceViewportRect.size.withX(width));
    }
}
exports.Flamechart = Flamechart;

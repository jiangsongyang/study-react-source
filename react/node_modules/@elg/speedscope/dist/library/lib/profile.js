"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallTreeProfileBuilder = exports.StackListProfileBuilder = exports.Profile = exports.CallTreeNode = exports.Frame = exports.HasWeights = void 0;
const utils_1 = require("./utils");
const value_formatters_1 = require("./value-formatters");
const demangleCppModule = Promise.resolve().then(() => __importStar(require('./demangle-cpp')));
// Force eager loading of the module
demangleCppModule.then(() => { });
class HasWeights {
    constructor() {
        this.selfWeight = 0;
        this.totalWeight = 0;
    }
    getSelfWeight() {
        return this.selfWeight;
    }
    getTotalWeight() {
        return this.totalWeight;
    }
    addToTotalWeight(delta) {
        this.totalWeight += delta;
    }
    addToSelfWeight(delta) {
        this.selfWeight += delta;
    }
    overwriteWeightWith(other) {
        this.selfWeight = other.selfWeight;
        this.totalWeight = other.totalWeight;
    }
}
exports.HasWeights = HasWeights;
let Frame = /** @class */ (() => {
    class Frame extends HasWeights {
        constructor(info) {
            super();
            this.key = info.key;
            this.name = info.name;
            this.file = info.file;
            this.line = info.line;
            this.col = info.col;
        }
        static getOrInsert(set, info) {
            return set.getOrInsert(new Frame(info));
        }
    }
    Frame.root = new Frame({
        key: '(speedscope root)',
        name: '(speedscope root)',
    });
    return Frame;
})();
exports.Frame = Frame;
class CallTreeNode extends HasWeights {
    constructor(frame, parent) {
        super();
        this.frame = frame;
        this.parent = parent;
        this.children = [];
        // If a node is "frozen", it means it should no longer be mutated.
        this.frozen = false;
    }
    isRoot() {
        return this.frame === Frame.root;
    }
    isFrozen() {
        return this.frozen;
    }
    freeze() {
        this.frozen = true;
    }
}
exports.CallTreeNode = CallTreeNode;
class Profile {
    constructor(totalWeight = 0) {
        this.name = '';
        this.frames = new utils_1.KeyedSet();
        // Profiles store two call-trees.
        //
        // The "append order" call tree is the one in which nodes are ordered in
        // whatever order they were appended to their parent.
        //
        // The "grouped" call tree is one in which each node has at most one child per
        // frame. Nodes are ordered in decreasing order of weight
        this.appendOrderCalltreeRoot = new CallTreeNode(Frame.root, null);
        this.groupedCalltreeRoot = new CallTreeNode(Frame.root, null);
        // List of references to CallTreeNodes at the top of the
        // stack at the time of the sample.
        this.samples = [];
        this.weights = [];
        this.valueFormatter = new value_formatters_1.RawValueFormatter();
        this.totalNonIdleWeight = null;
        this.totalWeight = totalWeight;
    }
    getAppendOrderCalltreeRoot() {
        return this.appendOrderCalltreeRoot;
    }
    getGroupedCalltreeRoot() {
        return this.groupedCalltreeRoot;
    }
    formatValue(v) {
        return this.valueFormatter.format(v);
    }
    setValueFormatter(f) {
        this.valueFormatter = f;
    }
    getWeightUnit() {
        return this.valueFormatter.unit;
    }
    getName() {
        return this.name;
    }
    setName(name) {
        this.name = name;
    }
    getTotalWeight() {
        return this.totalWeight;
    }
    getTotalNonIdleWeight() {
        if (this.totalNonIdleWeight === null) {
            this.totalNonIdleWeight = this.groupedCalltreeRoot.children.reduce((n, c) => n + c.getTotalWeight(), 0);
        }
        return this.totalNonIdleWeight;
    }
    // This is private because it should only be called in the ProfileBuilder
    // classes. Once a Profile instance has been constructed, it should be treated
    // as immutable.
    sortGroupedCallTree() {
        function visit(node) {
            node.children.sort((a, b) => -(a.getTotalWeight() - b.getTotalWeight()));
            node.children.forEach(visit);
        }
        visit(this.groupedCalltreeRoot);
    }
    forEachCallGrouped(openFrame, closeFrame) {
        function visit(node, start) {
            if (node.frame !== Frame.root) {
                openFrame(node, start);
            }
            let childTime = 0;
            node.children.forEach(function (child) {
                visit(child, start + childTime);
                childTime += child.getTotalWeight();
            });
            if (node.frame !== Frame.root) {
                closeFrame(node, start + node.getTotalWeight());
            }
        }
        visit(this.groupedCalltreeRoot, 0);
    }
    forEachCall(openFrame, closeFrame) {
        let prevStack = [];
        let value = 0;
        let sampleIndex = 0;
        for (let stackTop of this.samples) {
            // Find lowest common ancestor of the current stack and the previous one
            let lca = null;
            // This is O(n^2), but n should be relatively small here (stack height),
            // so hopefully this isn't much of a problem
            for (lca = stackTop; lca && lca.frame != Frame.root && prevStack.indexOf(lca) === -1; lca = lca.parent) { }
            // Close frames that are no longer open
            while (prevStack.length > 0 && utils_1.lastOf(prevStack) != lca) {
                const node = prevStack.pop();
                closeFrame(node, value);
            }
            // Open frames that are now becoming open
            const toOpen = [];
            for (let node = stackTop; node && node.frame != Frame.root && node != lca; node = node.parent) {
                toOpen.push(node);
            }
            toOpen.reverse();
            for (let node of toOpen) {
                openFrame(node, value);
            }
            prevStack = prevStack.concat(toOpen);
            value += this.weights[sampleIndex++];
        }
        // Close frames that are open at the end of the trace
        for (let i = prevStack.length - 1; i >= 0; i--) {
            closeFrame(prevStack[i], value);
        }
    }
    forEachFrame(fn) {
        this.frames.forEach(fn);
    }
    getProfileWithRecursionFlattened() {
        const builder = new CallTreeProfileBuilder();
        const stack = [];
        const framesInStack = new Set();
        function openFrame(node, value) {
            if (framesInStack.has(node.frame)) {
                stack.push(null);
            }
            else {
                framesInStack.add(node.frame);
                stack.push(node);
                builder.enterFrame(node.frame, value);
            }
        }
        function closeFrame(node, value) {
            const stackTop = stack.pop();
            if (stackTop) {
                framesInStack.delete(stackTop.frame);
                builder.leaveFrame(stackTop.frame, value);
            }
        }
        this.forEachCall(openFrame, closeFrame);
        const flattenedProfile = builder.build();
        flattenedProfile.name = this.name;
        flattenedProfile.valueFormatter = this.valueFormatter;
        // When constructing a profile with recursion flattened,
        // counter-intuitive things can happen to "self time" measurements
        // for functions.
        // For example, given the following list of stacks w/ weights:
        //
        // a 1
        // a;b;a 1
        // a;b;a;b;a 1
        // a;b;a 1
        //
        // The resulting profile with recursion flattened out will look like this:
        //
        // a 1
        // a;b 3
        //
        // Which is useful to view, but it's counter-intuitive to move self-time
        // for frames around, since analyzing the self-time of functions is an important
        // thing to be able to do accurately, and we don't want this to change when recursion
        // is flattened. To work around that, we'll just copy the weights directly from the
        // un-flattened profile.
        this.forEachFrame(f => {
            flattenedProfile.frames.getOrInsert(f).overwriteWeightWith(f);
        });
        return flattenedProfile;
    }
    getInvertedProfileForCallersOf(focalFrameInfo) {
        const focalFrame = Frame.getOrInsert(this.frames, focalFrameInfo);
        const builder = new StackListProfileBuilder();
        // TODO(jlfwong): Could construct this at profile
        // construction time rather than on demand.
        const nodes = [];
        function visit(node) {
            if (node.frame === focalFrame) {
                nodes.push(node);
            }
            else {
                for (let child of node.children) {
                    visit(child);
                }
            }
        }
        visit(this.appendOrderCalltreeRoot);
        for (let node of nodes) {
            const stack = [];
            for (let n = node; n != null && n.frame !== Frame.root; n = n.parent) {
                stack.push(n.frame);
            }
            builder.appendSampleWithWeight(stack, node.getTotalWeight());
        }
        const ret = builder.build();
        ret.name = this.name;
        ret.valueFormatter = this.valueFormatter;
        return ret;
    }
    getProfileForCalleesOf(focalFrameInfo) {
        const focalFrame = Frame.getOrInsert(this.frames, focalFrameInfo);
        const builder = new StackListProfileBuilder();
        function recordSubtree(focalFrameNode) {
            const stack = [];
            function visit(node) {
                stack.push(node.frame);
                builder.appendSampleWithWeight(stack, node.getSelfWeight());
                for (let child of node.children) {
                    visit(child);
                }
                stack.pop();
            }
            visit(focalFrameNode);
        }
        function findCalls(node) {
            if (node.frame === focalFrame) {
                recordSubtree(node);
            }
            else {
                for (let child of node.children) {
                    findCalls(child);
                }
            }
        }
        findCalls(this.appendOrderCalltreeRoot);
        const ret = builder.build();
        ret.name = this.name;
        ret.valueFormatter = this.valueFormatter;
        return ret;
    }
    // Demangle symbols for readability
    demangle() {
        return __awaiter(this, void 0, void 0, function* () {
            let demangleCpp = null;
            for (let frame of this.frames) {
                // This function converts a mangled C++ name such as "__ZNK7Support6ColorFeqERKS0_"
                // into a human-readable symbol (in this case "Support::ColorF::==(Support::ColorF&)")
                if (frame.name.startsWith('__Z')) {
                    if (!demangleCpp) {
                        demangleCpp = (yield demangleCppModule).demangleCpp;
                    }
                    frame.name = demangleCpp(frame.name);
                }
            }
        });
    }
    remapNames(callback) {
        for (let frame of this.frames) {
            frame.name = callback(frame.name);
        }
    }
}
exports.Profile = Profile;
class StackListProfileBuilder extends Profile {
    constructor() {
        super(...arguments);
        this.pendingSample = null;
    }
    _appendSample(stack, weight, useAppendOrder) {
        if (isNaN(weight))
            throw new Error('invalid weight');
        let node = useAppendOrder ? this.appendOrderCalltreeRoot : this.groupedCalltreeRoot;
        let framesInStack = new Set();
        for (let frameInfo of stack) {
            const frame = Frame.getOrInsert(this.frames, frameInfo);
            const last = useAppendOrder
                ? utils_1.lastOf(node.children)
                : node.children.find(c => c.frame === frame);
            if (last && !last.isFrozen() && last.frame == frame) {
                node = last;
            }
            else {
                const parent = node;
                node = new CallTreeNode(frame, node);
                parent.children.push(node);
            }
            node.addToTotalWeight(weight);
            // It's possible for the same frame to occur multiple
            // times in the same call stack due to either direct
            // or indirect recursion. We want to avoid counting that
            // frame multiple times for a single sample, we so just
            // track all of the unique frames that participated in
            // this call stack, then add to their weight at the end.
            framesInStack.add(node.frame);
        }
        node.addToSelfWeight(weight);
        if (useAppendOrder) {
            for (let child of node.children) {
                child.freeze();
            }
        }
        if (useAppendOrder) {
            node.frame.addToSelfWeight(weight);
            for (let frame of framesInStack) {
                frame.addToTotalWeight(weight);
            }
            if (node === utils_1.lastOf(this.samples)) {
                this.weights[this.weights.length - 1] += weight;
            }
            else {
                this.samples.push(node);
                this.weights.push(weight);
            }
        }
    }
    appendSampleWithWeight(stack, weight) {
        if (weight === 0) {
            // Samples with zero weight have no effect, so let's ignore them
            return;
        }
        if (weight < 0) {
            throw new Error('Samples must have positive weights');
        }
        this._appendSample(stack, weight, true);
        this._appendSample(stack, weight, false);
    }
    appendSampleWithTimestamp(stack, timestamp) {
        if (this.pendingSample) {
            if (timestamp < this.pendingSample.centralTimestamp) {
                throw new Error('Timestamps received out of order');
            }
            const endTimestamp = (timestamp + this.pendingSample.centralTimestamp) / 2;
            this.appendSampleWithWeight(this.pendingSample.stack, endTimestamp - this.pendingSample.startTimestamp);
            this.pendingSample = { stack, startTimestamp: endTimestamp, centralTimestamp: timestamp };
        }
        else {
            this.pendingSample = { stack, startTimestamp: timestamp, centralTimestamp: timestamp };
        }
    }
    build() {
        if (this.pendingSample) {
            if (this.samples.length > 0) {
                this.appendSampleWithWeight(this.pendingSample.stack, this.pendingSample.centralTimestamp - this.pendingSample.startTimestamp);
            }
            else {
                // There is only a single sample. In this case, units will be meaningless,
                // so we'll append with a weight of 1 and also clear any value formatter
                this.appendSampleWithWeight(this.pendingSample.stack, 1);
                this.setValueFormatter(new value_formatters_1.RawValueFormatter());
            }
        }
        this.totalWeight = Math.max(this.totalWeight, this.weights.reduce((a, b) => a + b, 0));
        this.sortGroupedCallTree();
        return this;
    }
}
exports.StackListProfileBuilder = StackListProfileBuilder;
// As an alternative API for importing profiles more efficiently, provide a
// way to open & close frames directly without needing to construct tons of
// arrays as intermediaries.
class CallTreeProfileBuilder extends Profile {
    constructor() {
        super(...arguments);
        this.appendOrderStack = [this.appendOrderCalltreeRoot];
        this.groupedOrderStack = [this.groupedCalltreeRoot];
        this.framesInStack = new Map();
        this.stack = [];
        this.lastValue = 0;
    }
    addWeightsToFrames(value) {
        const delta = value - this.lastValue;
        for (let frame of this.framesInStack.keys()) {
            frame.addToTotalWeight(delta);
        }
        const stackTop = utils_1.lastOf(this.stack);
        if (stackTop) {
            stackTop.addToSelfWeight(delta);
        }
    }
    addWeightsToNodes(value, stack) {
        const delta = value - this.lastValue;
        for (let node of stack) {
            node.addToTotalWeight(delta);
        }
        const stackTop = utils_1.lastOf(stack);
        if (stackTop) {
            stackTop.addToSelfWeight(delta);
        }
    }
    _enterFrame(frame, value, useAppendOrder) {
        let stack = useAppendOrder ? this.appendOrderStack : this.groupedOrderStack;
        this.addWeightsToNodes(value, stack);
        let prevTop = utils_1.lastOf(stack);
        if (prevTop) {
            if (useAppendOrder) {
                const delta = value - this.lastValue;
                if (delta > 0) {
                    this.samples.push(prevTop);
                    this.weights.push(value - this.lastValue);
                }
                else if (delta < 0) {
                    throw new Error(`Samples must be provided in increasing order of cumulative value. Last sample was ${this.lastValue}, this sample was ${value}`);
                }
            }
            const last = useAppendOrder
                ? utils_1.lastOf(prevTop.children)
                : prevTop.children.find(c => c.frame === frame);
            let node;
            if (last && !last.isFrozen() && last.frame == frame) {
                node = last;
            }
            else {
                node = new CallTreeNode(frame, prevTop);
                prevTop.children.push(node);
            }
            stack.push(node);
        }
    }
    enterFrame(frameInfo, value) {
        const frame = Frame.getOrInsert(this.frames, frameInfo);
        this.addWeightsToFrames(value);
        this._enterFrame(frame, value, true);
        this._enterFrame(frame, value, false);
        this.stack.push(frame);
        const frameCount = this.framesInStack.get(frame) || 0;
        this.framesInStack.set(frame, frameCount + 1);
        this.lastValue = value;
    }
    _leaveFrame(frame, value, useAppendOrder) {
        let stack = useAppendOrder ? this.appendOrderStack : this.groupedOrderStack;
        this.addWeightsToNodes(value, stack);
        if (useAppendOrder) {
            const leavingStackTop = this.appendOrderStack.pop();
            if (leavingStackTop == null) {
                throw new Error(`Trying to leave ${frame.key} when stack is empty`);
            }
            if (this.lastValue == null) {
                throw new Error(`Trying to leave a ${frame.key} before any have been entered`);
            }
            leavingStackTop.freeze();
            if (leavingStackTop.frame.key !== frame.key) {
                throw new Error(`Tried to leave frame "${frame.name}" while frame "${leavingStackTop.frame.name}" was at the top at ${value}`);
            }
            const delta = value - this.lastValue;
            if (delta > 0) {
                this.samples.push(leavingStackTop);
                this.weights.push(value - this.lastValue);
            }
            else if (delta < 0) {
                throw new Error(`Samples must be provided in increasing order of cumulative value. Last sample was ${this
                    .lastValue}, this sample was ${value}`);
            }
        }
        else {
            this.groupedOrderStack.pop();
        }
    }
    leaveFrame(frameInfo, value) {
        const frame = Frame.getOrInsert(this.frames, frameInfo);
        this.addWeightsToFrames(value);
        this._leaveFrame(frame, value, true);
        this._leaveFrame(frame, value, false);
        this.stack.pop();
        const frameCount = this.framesInStack.get(frame);
        if (frameCount == null)
            return;
        if (frameCount === 1) {
            this.framesInStack.delete(frame);
        }
        else {
            this.framesInStack.set(frame, frameCount - 1);
        }
        this.lastValue = value;
        this.totalWeight = Math.max(this.totalWeight, this.lastValue);
    }
    build() {
        // Each stack is expected to contain a single node which we initialize to be
        // the root node.
        if (this.appendOrderStack.length > 1 || this.groupedOrderStack.length > 1) {
            throw new Error('Tried to complete profile construction with a non-empty stack');
        }
        this.sortGroupedCallTree();
        return this;
    }
}
exports.CallTreeProfileBuilder = CallTreeProfileBuilder;

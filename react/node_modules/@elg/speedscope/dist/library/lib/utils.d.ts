export declare function lastOf<T>(ts: T[]): T | null;
export declare function sortBy<T>(ts: T[], key: (t: T) => number | string): void;
export declare function getOrInsert<K, V>(map: Map<K, V>, k: K, fallback: (k: K) => V): V;
export declare function getOrElse<K, V>(map: Map<K, V>, k: K, fallback: (k: K) => V): V;
export declare function getOrThrow<K, V>(map: Map<K, V>, k: K): V;
export interface HasKey {
    readonly key: string | number;
}
export declare class KeyedSet<T extends HasKey> implements Iterable<T> {
    private map;
    getOrInsert(t: T): T;
    forEach(fn: (t: T) => void): void;
    [Symbol.iterator](): IterableIterator<T>;
}
export declare function itMap<T, U>(it: Iterable<T>, f: (t: T) => U): Iterable<U>;
export declare function itForEach<T>(it: Iterable<T>, f: (t: T) => void): void;
export declare function itReduce<T, U>(it: Iterable<T>, f: (a: U, b: T) => U, init: U): U;
export declare function zeroPad(s: string, width: number): string;
export declare function formatPercent(percent: number): string;
export declare function fract(x: number): number;
export declare function triangle(x: number): number;
export declare function binarySearch(lo: number, hi: number, f: (val: number) => number, target: number, targetRangeSize?: number): [number, number];
export declare function noop(...args: any[]): void;
export declare function objectsHaveShallowEquality<T extends object>(a: T, b: T): boolean;
export declare function memoizeByShallowEquality<T extends object, U>(cb: (t: T) => U): (t: T) => U;
export declare function memoizeByReference<T, U>(cb: (t: T) => U): (t: T) => U;
export declare function lazyStatic<T>(cb: () => T): () => T;
export declare function decodeBase64(encoded: string): Uint8Array;

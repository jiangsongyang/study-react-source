/**
 * Flowtype definitions for math
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 * @flow
 */

declare export function clamp(
  x: number,
  minVal: number,
  maxVal: number
): number;
declare export class Vec2 {
  +x: number;
  +y: number;
  constructor(x: number, y: number): this;
  withX(x: number): Vec2;
  withY(y: number): Vec2;
  plus(other: Vec2): Vec2;
  minus(other: Vec2): Vec2;
  times(scalar: number): Vec2;
  timesPointwise(other: Vec2): Vec2;
  dividedByPointwise(other: Vec2): Vec2;
  dot(other: Vec2): number;
  equals(other: Vec2): boolean;
  approxEquals(other: Vec2, epsilon?: number): boolean;
  length2(): number;
  length(): number;
  abs(): Vec2;
  static min(a: Vec2, b: Vec2): Vec2;
  static max(a: Vec2, b: Vec2): Vec2;
  static clamp(v: Vec2, min: Vec2, max: Vec2): Vec2;
  static zero: Vec2;
  static unit: Vec2;
  flatten(): [number, number];
}
declare export class AffineTransform {
  +m00: number;
  +m01: number;
  +m02: number;
  +m10: number;
  +m11: number;
  +m12: number;
  constructor(
    m00?: number,
    m01?: number,
    m02?: number,
    m10?: number,
    m11?: number,
    m12?: number
  ): this;
  withScale(s: Vec2): AffineTransform;
  static withScale(s: Vec2): AffineTransform;
  scaledBy(s: Vec2): AffineTransform;
  getScale(): Vec2;
  withTranslation(t: Vec2): AffineTransform;
  static withTranslation(t: Vec2): AffineTransform;
  getTranslation(): Vec2;
  translatedBy(t: Vec2): AffineTransform;
  static betweenRects(from: Rect, to: Rect): AffineTransform;
  times(other: AffineTransform): AffineTransform;
  equals(other: AffineTransform): boolean;
  approxEquals(other: AffineTransform, epsilon?: number): boolean;
  timesScalar(s: number): AffineTransform;
  det(): number;
  adj(): AffineTransform;
  inverted(): AffineTransform | null;
  transformVector(v: Vec2): Vec2;
  inverseTransformVector(v: Vec2): Vec2 | null;
  transformPosition(v: Vec2): Vec2;
  inverseTransformPosition(v: Vec2): Vec2 | null;
  transformRect(r: Rect): Rect;
  inverseTransformRect(r: Rect): Rect | null;
  flatten(): [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number
  ];
}
declare export class Rect {
  +origin: Vec2;
  +size: Vec2;
  constructor(origin: Vec2, size: Vec2): this;
  isEmpty(): boolean;
  width(): number;
  height(): number;
  left(): number;
  right(): number;
  top(): number;
  bottom(): number;
  topLeft(): Vec2;
  topRight(): Vec2;
  bottomRight(): Vec2;
  bottomLeft(): Vec2;
  withOrigin(origin: Vec2): Rect;
  withSize(size: Vec2): Rect;
  closestPointTo(p: Vec2): Vec2;
  distanceFrom(p: Vec2): number;
  contains(p: Vec2): boolean;
  hasIntersectionWith(other: Rect): boolean;
  intersectWith(other: Rect): Rect;
  equals(other: Rect): boolean;
  approxEquals(other: Rect): boolean;
  area(): number;
  static empty: Rect;
  static unit: Rect;
  static NDC: Rect;
}
